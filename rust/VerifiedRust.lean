-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [verified_rust]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace verified_rust

/- [verified_rust::fibonacci::fib_iter]: loop 0:
   Source: 'src/fibonacci.rs', lines 30:4-35:5 -/
def fibonacci.fib_iter_loop
  (n : U32) (prev : U64) (curr : U64) (i : U32) : Result U64 := do
  if i <= n
  then
    let next ← (↑(core.num.U64.wrapping_add prev curr) : Result U64)
    let i1 ← i + 1#u32
    fibonacci.fib_iter_loop n curr next i1
  else ok curr
partial_fixpoint

/- [verified_rust::fibonacci::fib_iter]:
   Source: 'src/fibonacci.rs', lines 18:0-38:1 -/
def fibonacci.fib_iter (n : U32) : Result U64 := do
  if n = 0#u32
  then ok 0#u64
  else
    if n = 1#u32
    then ok 1#u64
    else fibonacci.fib_iter_loop n 0#u64 1#u64 2#u32

/- [verified_rust::fibonacci::fib_checked]: loop 0:
   Source: 'src/fibonacci.rs', lines 55:4-67:1 -/
def fibonacci.fib_checked_loop
  (n : U32) (prev : U64) (curr : U64) (i : U32) : Result (Option U64) := do
  if i <= n
  then
    let o ← (↑(U64.checked_add prev curr) : Result (Option U64))
    match o with
    | none => ok none
    | some next =>
      let i1 ← i + 1#u32
      fibonacci.fib_checked_loop n curr next i1
  else ok (some curr)
partial_fixpoint

/- [verified_rust::fibonacci::fib_checked]:
   Source: 'src/fibonacci.rs', lines 43:0-67:1 -/
def fibonacci.fib_checked (n : U32) : Result (Option U64) := do
  if n = 0#u32
  then ok (some 0#u64)
  else
    if n = 1#u32
    then ok (some 1#u64)
    else fibonacci.fib_checked_loop n 0#u64 1#u64 2#u32

/- [verified_rust::fibonacci::fib_bounded]:
   Source: 'src/fibonacci.rs', lines 72:0-77:1 -/
def fibonacci.fib_bounded (n : U32) (max_n : U32) : Result (Option U64) := do
  if n > max_n
  then ok none
  else let i ← fibonacci.fib_iter n
       ok (some i)

/- [verified_rust::fibonacci::fib_sequence]: loop 0:
   Source: 'src/fibonacci.rs', lines 96:4-100:5 -/
def fibonacci.fib_sequence_loop
  (n : Usize) (result : alloc.vec.Vec U64) (i : Usize) :
  Result (alloc.vec.Vec U64)
  := do
  if i < n
  then
    let i1 ← i - 1#usize
    let i2 ←
      alloc.vec.Vec.index (core.slice.index.SliceIndexUsizeSlice U64) result i1
    let i3 ← i - 2#usize
    let i4 ←
      alloc.vec.Vec.index (core.slice.index.SliceIndexUsizeSlice U64) result i3
    let next ← (↑(core.num.U64.wrapping_add i2 i4) : Result U64)
    let result1 ← alloc.vec.Vec.push result next
    let i5 ← i + 1#usize
    fibonacci.fib_sequence_loop n result1 i5
  else ok result
partial_fixpoint

/- [verified_rust::fibonacci::fib_sequence]:
   Source: 'src/fibonacci.rs', lines 82:0-103:1 -/
def fibonacci.fib_sequence (n : Usize) : Result (alloc.vec.Vec U64) := do
  let result := alloc.vec.Vec.with_capacity U64 n
  if n = 0#usize
  then ok result
  else
    let result1 ← alloc.vec.Vec.push result 0#u64
    if n = 1#usize
    then ok result1
    else
      let result2 ← alloc.vec.Vec.push result1 1#u64
      fibonacci.fib_sequence_loop n result2 2#usize

/- [verified_rust::fibonacci::is_fibonacci]: loop 0:
   Source: 'src/fibonacci.rs', lines 115:4-125:1 -/
def fibonacci.is_fibonacci_loop
  (x : U64) (prev : U64) (curr : U64) : Result Bool := do
  if curr < x
  then
    let o ← (↑(U64.checked_add prev curr) : Result (Option U64))
    match o with
    | none => ok false
    | some n => fibonacci.is_fibonacci_loop x curr n
  else ok (curr = x)
partial_fixpoint

/- [verified_rust::fibonacci::is_fibonacci]:
   Source: 'src/fibonacci.rs', lines 107:0-125:1 -/
def fibonacci.is_fibonacci (x : U64) : Result Bool := do
  if x = 0#u64
  then ok true
  else if x = 1#u64
       then ok true
       else fibonacci.is_fibonacci_loop x 0#u64 1#u64

/- [verified_rust::fibonacci::fib_index]: loop 0:
   Source: 'src/fibonacci.rs', lines 142:4-157:1 -/
def fibonacci.fib_index_loop
  (x : U64) (prev : U64) (curr : U64) (idx : U32) : Result (Option U32) := do
  if curr < x
  then
    let o ← (↑(U64.checked_add prev curr) : Result (Option U64))
    match o with
    | none => ok none
    | some n => let idx1 ← idx + 1#u32
                fibonacci.fib_index_loop x curr n idx1
  else if curr = x
       then ok (some idx)
       else ok none
partial_fixpoint

/- [verified_rust::fibonacci::fib_index]:
   Source: 'src/fibonacci.rs', lines 130:0-157:1 -/
def fibonacci.fib_index (x : U64) : Result (Option U32) := do
  if x = 0#u64
  then ok (some 0#u32)
  else
    if x = 1#u64
    then ok (some 1#u32)
    else fibonacci.fib_index_loop x 0#u64 1#u64 1#u32

/- [verified_rust::fibonacci::fib_matrix]: loop 0:
   Source: 'src/fibonacci.rs', lines 181:4-205:5 -/
def fibonacci.fib_matrix_loop
  (a : U64) (b : U64) (c : U64) (d : U64) (ra : U64) (rb : U64) (rc : U64)
  (rd : U64) (exp : U32) :
  Result U64
  := do
  if exp > 0#u32
  then
    let i ← exp % 2#u32
    let (ra1, rb1, rc1, rd1) ←
      if i = 1#u32
      then
        let i1 ← (↑(core.num.U64.wrapping_mul ra a) : Result U64)
        let i2 ← (↑(core.num.U64.wrapping_mul rb c) : Result U64)
        let new_ra ← (↑(core.num.U64.wrapping_add i1 i2) : Result U64)
        let i3 ← (↑(core.num.U64.wrapping_mul ra b) : Result U64)
        let i4 ← (↑(core.num.U64.wrapping_mul rb d) : Result U64)
        let new_rb ← (↑(core.num.U64.wrapping_add i3 i4) : Result U64)
        let i5 ← (↑(core.num.U64.wrapping_mul rc a) : Result U64)
        let i6 ← (↑(core.num.U64.wrapping_mul rd c) : Result U64)
        let new_rc ← (↑(core.num.U64.wrapping_add i5 i6) : Result U64)
        let i7 ← (↑(core.num.U64.wrapping_mul rc b) : Result U64)
        let i8 ← (↑(core.num.U64.wrapping_mul rd d) : Result U64)
        let new_rd ← (↑(core.num.U64.wrapping_add i7 i8) : Result U64)
        ok (new_ra, new_rb, new_rc, new_rd)
      else ok (ra, rb, rc, rd)
    let i1 ← (↑(core.num.U64.wrapping_mul a a) : Result U64)
    let i2 ← (↑(core.num.U64.wrapping_mul b c) : Result U64)
    let new_a ← (↑(core.num.U64.wrapping_add i1 i2) : Result U64)
    let i3 ← (↑(core.num.U64.wrapping_mul a b) : Result U64)
    let i4 ← (↑(core.num.U64.wrapping_mul b d) : Result U64)
    let new_b ← (↑(core.num.U64.wrapping_add i3 i4) : Result U64)
    let i5 ← (↑(core.num.U64.wrapping_mul c a) : Result U64)
    let i6 ← (↑(core.num.U64.wrapping_mul d c) : Result U64)
    let new_c ← (↑(core.num.U64.wrapping_add i5 i6) : Result U64)
    let i7 ← (↑(core.num.U64.wrapping_mul c b) : Result U64)
    let i8 ← (↑(core.num.U64.wrapping_mul d d) : Result U64)
    let new_d ← (↑(core.num.U64.wrapping_add i7 i8) : Result U64)
    let exp1 ← exp / 2#u32
    fibonacci.fib_matrix_loop new_a new_b new_c new_d ra1 rb1 rc1 rd1 exp1
  else ok ra
partial_fixpoint

/- [verified_rust::fibonacci::fib_matrix]:
   Source: 'src/fibonacci.rs', lines 162:0-208:1 -/
def fibonacci.fib_matrix (n : U32) : Result U64 := do
  if n = 0#u32
  then ok 0#u64
  else
    let exp ← n - 1#u32
    fibonacci.fib_matrix_loop 1#u64 1#u64 1#u64 0#u64 1#u64 0#u64 0#u64 1#u64
      exp

/- [verified_rust::math::add]:
   Source: 'src/math.rs', lines 5:0-7:1 -/
def math.add (a : U32) (b : U32) : Result U32 := do
  ok (core.num.U32.wrapping_add a b)

/- [verified_rust::math::mul]:
   Source: 'src/math.rs', lines 12:0-14:1 -/
def math.mul (a : U32) (b : U32) : Result U32 := do
  ok (core.num.U32.wrapping_mul a b)

/- [verified_rust::math::div]:
   Source: 'src/math.rs', lines 19:0-25:1 -/
def math.div (a : U32) (b : U32) : Result (Option U32) := do
  if b = 0#u32
  then ok none
  else let i ← a / b
       ok (some i)

/- [verified_rust::math::modulo]:
   Source: 'src/math.rs', lines 28:0-34:1 -/
def math.modulo (a : U32) (b : U32) : Result (Option U32) := do
  if b = 0#u32
  then ok none
  else let i ← a % b
       ok (some i)

/- [verified_rust::math::gcd]: loop 0:
   Source: 'src/math.rs', lines 41:4-45:5 -/
def math.gcd_loop (a : U32) (b : U32) : Result U32 := do
  if b != 0#u32
  then let b1 ← a % b
       math.gcd_loop b b1
  else ok a
partial_fixpoint

/- [verified_rust::math::gcd]:
   Source: 'src/math.rs', lines 40:0-47:1 -/
@[reducible]
def math.gcd (a : U32) (b : U32) : Result U32 := do
  math.gcd_loop a b

/- [verified_rust::math::lcm]:
   Source: 'src/math.rs', lines 51:0-59:1 -/
def math.lcm (a : U32) (b : U32) : Result (Option U32) := do
  if a = 0#u32
  then ok (some 0#u32)
  else
    if b = 0#u32
    then ok (some 0#u32)
    else
      let g ← math.gcd a b
      let i ← a / g
      let i1 ← (↑(core.num.U32.wrapping_mul i b) : Result U32)
      ok (some i1)

/- [verified_rust::math::pow]: loop 0:
   Source: 'src/math.rs', lines 69:4-75:5 -/
def math.pow_loop (result : U32) (base : U32) (exp : U32) : Result U32 := do
  if exp > 0#u32
  then
    let i ← exp % 2#u32
    let result1 ←
      if i = 1#u32
      then ok (core.num.U32.wrapping_mul result base)
      else ok result
    let exp1 ← exp / 2#u32
    let base1 ← (↑(core.num.U32.wrapping_mul base base) : Result U32)
    math.pow_loop result1 base1 exp1
  else ok result
partial_fixpoint

/- [verified_rust::math::pow]:
   Source: 'src/math.rs', lines 64:0-77:1 -/
@[reducible]
def math.pow (base : U32) (exp : U32) : Result U32 := do
  math.pow_loop 1#u32 base exp

/- [verified_rust::math::is_even]:
   Source: 'src/math.rs', lines 81:0-83:1 -/
def math.is_even (n : U32) : Result Bool := do
  let i ← n % 2#u32
  ok (i = 0#u32)

/- [verified_rust::math::is_odd]:
   Source: 'src/math.rs', lines 86:0-88:1 -/
def math.is_odd (n : U32) : Result Bool := do
  let i ← n % 2#u32
  ok (i = 1#u32)

/- [verified_rust::math::abs_diff]:
   Source: 'src/math.rs', lines 92:0-98:1 -/
def math.abs_diff (a : U32) (b : U32) : Result U32 := do
  if a > b
  then a - b
  else b - a

/- [verified_rust::math::factorial]: loop 0:
   Source: 'src/math.rs', lines 111:4-114:5 -/
def math.factorial_loop (n : U32) (result : U32) (i : U32) : Result U32 := do
  if i <= n
  then
    let result1 ← (↑(core.num.U32.wrapping_mul result i) : Result U32)
    let i1 ← i + 1#u32
    math.factorial_loop n result1 i1
  else ok result
partial_fixpoint

/- [verified_rust::math::factorial]:
   Source: 'src/math.rs', lines 103:0-116:1 -/
def math.factorial (n : U32) : Result (Option U32) := do
  if n > 12#u32
  then ok none
  else let result ← math.factorial_loop n 1#u32 2#u32
       ok (some result)

/- [verified_rust::math::is_prime]: loop 0:
   Source: 'src/math.rs', lines 134:4-141:1 -/
def math.is_prime_loop (n : U32) (i : U32) : Result Bool := do
  let i1 ← (↑(core.num.U32.wrapping_mul i i) : Result U32)
  if i1 <= n
  then
    let i2 ← n % i
    if i2 = 0#u32
    then ok false
    else let i3 ← i + 2#u32
         math.is_prime_loop n i3
  else ok true
partial_fixpoint

/- [verified_rust::math::is_prime]:
   Source: 'src/math.rs', lines 122:0-141:1 -/
def math.is_prime (n : U32) : Result Bool := do
  if n < 2#u32
  then ok false
  else
    if n = 2#u32
    then ok true
    else
      let i ← n % 2#u32
      if i = 0#u32
      then ok false
      else math.is_prime_loop n 3#u32

/- [verified_rust::simple::add]:
   Source: 'src/simple.rs', lines 5:0-7:1 -/
def simple.add (a : U32) (b : U32) : Result U32 := do
  a + b

/- [verified_rust::simple::mul]:
   Source: 'src/simple.rs', lines 10:0-12:1 -/
def simple.mul (a : U32) (b : U32) : Result U32 := do
  a * b

/- [verified_rust::simple::gcd]:
   Source: 'src/simple.rs', lines 17:0-23:1 -/
def simple.gcd (a : U32) (b : U32) : Result U32 := do
  if b = 0#u32
  then ok a
  else let i ← a % b
       simple.gcd b i
partial_fixpoint

/- [verified_rust::simple::factorial]:
   Source: 'src/simple.rs', lines 28:0-34:1 -/
def simple.factorial (n : U32) : Result U32 := do
  if n = 0#u32
  then ok 1#u32
  else let i ← n - 1#u32
       let i1 ← simple.factorial i
       n * i1
partial_fixpoint

/- [verified_rust::simple::pow]:
   Source: 'src/simple.rs', lines 37:0-43:1 -/
def simple.pow (base : U32) (exp : U32) : Result U32 := do
  if exp = 0#u32
  then ok 1#u32
  else let i ← exp - 1#u32
       let i1 ← simple.pow base i
       base * i1
partial_fixpoint

/- [verified_rust::simple::is_even]:
   Source: 'src/simple.rs', lines 46:0-48:1 -/
def simple.is_even (n : U32) : Result Bool := do
  let i ← n % 2#u32
  ok (i = 0#u32)

/- [verified_rust::simple::abs_diff]:
   Source: 'src/simple.rs', lines 51:0-57:1 -/
def simple.abs_diff (a : U32) (b : U32) : Result U32 := do
  if a > b
  then a - b
  else b - a

end verified_rust
